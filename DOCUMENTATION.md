# Final Factory Mod Documentation

This is the official documentation on how to mod Final Factory and how its internal systems work.

## Reverse Engineering

You may (or may not) have noticed, but Final Factory does not contain a restrictive EULA preventing you from decompiling
or reverse engineering for the purposes of mod development.  **This is intentional.**

The developers of Final Factory strongly encourage you to use the necessary tools, including reverse engineering, for
the purpose of mod development.  Please do not use our sources, assets, and other IP to make competing products or for 
other commercial purposes--but otherwise, we're here to support you on your Modding journey.  Please reach out in 
Discord--we're happy to help and often share source code snippets to help.

## Configuration vs Behavioral Mods

There are two types ways to mod Final Factory:

1. Configuration-driven mods (Simple)  
These mods are able to update the configuration for existing entities and add new models, ships, and objects to the world.  For instance, adjusting the amount of resources contained with an asteroid is something that can be handled with pure configuration overrides.

2. Behavioral mods (Advanced)  
These mods implement their own ECS Systems which override or replace existing system behavior.  These are much more advanced, and can modify nearly any behavior in the game, but are more likely to break from game upgrades and introduce bugs.

Some mods have both updated configuration and behavior.

**If you're new, it's strongly recommended to do a configuration-based mod before moving to altering behavior.**

## Unity ECS Overview

To deeply mod Final Factory and modify behavior, you'll need to have a strong understanding of Unity ECS.  This is
outside the scope of this document, but some good resources to get started are here:
https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html

Final Factory heavily uses Unity ECS to drive nearly all built-in behavior.  While a few things use Unity monobehaviors,
the vast majority of behavior is driven by Unity Systems.

## Final Factory System Organization and Naming

Final Factory's system groups are defined in SystemGroups.cs.

Final Factory uses the following system groups that run in the following order:  
Early -> PreTransform -> Transform (Unity) -> PostTransform -> ItemFinalizer -> Late

(There are a few other system groups, but these are not typically used and described here)

System update order is automatically generated by [Unity's automatic logic](https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-update-order.html#update-order-of-systems).  Mods **MUST NOT** use OrderFirst or
OrderLast in systems they create, lest they create unexpected dependencies or undefined system behavior that could
change from version to version.  Creators should feel free to use UpdateBefore and UpdateAfter semantics to control
system execution order.

### System Groups

### Early
Early system groups do setup and other initialization operations at the beginning of every frame.  For example, setting
up the current time delta, heartbeat, and other initial frame data all happens in early.

### PreTransform
Pretransform contains a large number of systems that need to setup parameters before objects are moved in the scene.
All systems that want to do things like update the position or velocity of objects should go into this group.

### Transform
This is actually not a FF System Group--it's built-in to Unity.  While you should not add systems here, it's important
to understand that this is the point at which Unity entities are manipulated and moved in the world.  Therefore, if you
do something like update the position of an object after transform, it won't update until the following frame.

### PostTransform
PostTransform is where most of the systems go.  At this point, everything is located in the world exactly where it
should be, so this is an excellent time to update crafting progress, heat, damage, and most other attributes about the
world.  In short, this is the point in the calculation where the world is "correct", and any system that cares about
that should be placed here.

### ItemFinalizer
This system group is typically used to place objects in the world that result from pretransform and post transform.  By
placing objects here, we make sure the world isn't changing in the middle of PostTransform, causing race conditions and
other hard to diagnose bugs.

### Late
Late system groups typically do cleanup, such as deleting destroyed entities and objects from the game.  Deleting
entities only at the end of frames greatly simplifies the architecture and avoids errors operating on destroyed entities.

Note: For performance reasons, the ECB updates and Entity Deletion from the ItemFinalizer and Late system group may not occur until the 
beginning of the **next** frame.

### Fixed vs Controller
For each of the above phases, there is both a "Fixed" and a "Controller" variant of the group.  

System Groups are predictably named: FF<Fixed/Controller><Phase>Group
 
Examples:  
FFControllerPostTransformGroup  
FFFixedPostTransformGroup

Each group has a different purpose, described below.

**Controller Groups:**  
These run on every frame that is rendered, making them ideal for animations, ship movement, and other updates where 
perfectly smooth movement is desired.  DeltaTime for these systems is based on the amount of time passed since the last
render pass.

**Fixed groups:**  
These run on every factory simulation and should be used for any action that updates factory state, such as crafting,
inventory updates, etc.  

When in doubt, use the Fixed group.  Creating Controller groups that affect factory state can result in multiplayer 
desyncs.

The separation between render and simulation ensures that highly fluid movement, animations, and behavior exist on high end systems while factory
simulation is predictable.  

### Rate Limiting

In future versions, rate limiting will be turned on (likely 60UPS--Updates per Second).  This is required for the 
multiplayer rollout. When this happens, Delta time for Fixed groups will be 1000ms/UPS, which means that if the game 
cannot keep up, the user will experience time dilation in order to keep simulation consistent.  This is similar to how 
Factorio works.  You can see this behavior by running "setRateLimit <UPS>" in the console.

If FPS > UPS, you will see multiple calls to Update() methods in Controller groups for each
Fixed group's Update() call.  If FPS goes below target UPS, Fixed system groups will run on every Controller Update() 
call.

## Entity Lifecycle & Deletion

While Entities can be created or modified in any system in any stage by making the necessary change via an entity 
command buffer, deletion has special rules.  Keep in mind that any 
[structural modifications to entities ](https://docs.unity3d.com/Packages/com.unity.entities@1.4/manual/concepts-structural-changes.html) 
is fairly slow in Unity and should be avoided when possible.  It is usually better to set values on a Component and
adjust them instead of adding/removing components from an entity.

### Deletion
Systems **MUST NOT** call EntityManager/ECB.DestroyEntity() directly.  If you wish to delete an entity, systems
(including modded systems) must instead add the \<DeletionMarker\> component to the entity.  This component will cause
FinalFactory's systems to automatically destroy this entity at the end of the frame.  Systems should generally ignore
entities containing <DeletionMarker> by using a .WithNone\<DeletionMarker\>() in their queries.

If you have any last minute cleanup you wish to trigger for entities that are about to be deleted, this **SHOULD BE**
performed in FFControllerLateGroup, not FFFixedLateGroup.  Entities are deleted on every frame, but at high FPS, Fixed
groups do not run on every frame, so a cleanup system in Fixed may not see an entity before it's deleted.